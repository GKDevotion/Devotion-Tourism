<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>World Analog Clocks â€” Singapore, New Delhi, Dubai, London, New York</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <style>
    :root {
      --clock-size: 180px;
      --label-color: #fff;
      --bg: linear-gradient(180deg, #0b6b78 0%, #6ec1c8 100%);
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: var(--bg);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px;
    }

    .clocks-wrap {
      width: 100%;
      max-width: 1200px;
      display: flex;
      gap: 40px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    .clock-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
      flex: 1 0 160px;
      min-width: 140px;
    }

    canvas.clock {
      width: var(--clock-size);
      height: var(--clock-size);
      background: transparent;
      border-radius: 50%;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
    }

    .label {
      color: var(--label-color);
      font-weight: 600;
      letter-spacing: .06em;
    }

    /* small screens */
    @media (max-width:700px) {
      .clocks-wrap {
        gap: 20px;
      }

      :root {
        --clock-size: 240px;
      }
    }
  </style>
</head>

<body>

  <!-- hidden local image (your uploaded file) -->
  <img id="clockFaceImg" src="analog-watch.png" alt="clock face"
    style="display:none" />

  <div class="clocks-wrap" id="clocks">
    <!-- cards will be created by jQuery -->
  </div>

  <script>
    $(function () {
      // time zones and labels
      const clocks = [
        { id: 'sg', label: 'SINGAPORE', timeZone: 'Asia/Singapore' },
        { id: 'del', label: 'NEW DELHI', timeZone: 'Asia/Kolkata' }, // India uses Asia/Kolkata (UTC+5:30)
        { id: 'dub', label: 'DUBAI', timeZone: 'Asia/Dubai' },
        { id: 'lon', label: 'LONDON', timeZone: 'Europe/London' }, // respects DST
        { id: 'ny', label: 'NEW YORK', timeZone: 'America/New_York' } // respects DST
      ];

      // create DOM
      const $wrap = $('#clocks');
      clocks.forEach(c => {
        const $card = $(`
        <div class="clock-card">
          <canvas id="canvas-${c.id}" class="clock" aria-label="${c.label} clock"></canvas>
          <div class="label">${c.label}</div>
        </div>
      `);
        $wrap.append($card);
        // attach timezone info
        $card.data('tz', c.timeZone);
      });

      // helper: get hour/min/sec for a timezone (using Intl.formatToParts)
      function getTimePartsForTimeZone(timeZone) {
        // use 24-hour clock to avoid AM/PM confusion
        const fmt = new Intl.DateTimeFormat('en-US', {
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          timeZone: timeZone
        });
        const parts = fmt.formatToParts(new Date());
        const p = {};
        parts.forEach(part => {
          if (part.type === 'hour') p.hour = parseInt(part.value, 10);
          if (part.type === 'minute') p.minute = parseInt(part.value, 10);
          if (part.type === 'second') p.second = parseInt(part.value, 10);
        });
        return p;
      }

      // initialize canvases and drawing context objects
      const canvases = [];
      $('.clock').each(function () {
        const canvas = this;
        const $canvas = $(this);
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // set size with DPR scaling
        const cssW = parseInt(getComputedStyle(canvas).width, 10);
        const cssH = parseInt(getComputedStyle(canvas).height, 10);
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
        canvases.push({ canvas, ctx, $canvas, dpr });
      });

      // load face image (optional) and then start render loop
      const faceImg = document.getElementById('clockFaceImg');
      let faceReady = false;
      faceImg.onload = function () { faceReady = true; };
      // If image already cached, onload may not fire; check naturalWidth
      if (faceImg.complete && faceImg.naturalWidth) faceReady = true;

      // draw single clock with provided hour/min/sec into ctx
      function drawClock(ctx, size, h, m, s, faceImg) {
        const cx = size / 2;
        const cy = size / 2;
        const radius = Math.min(size / 2, size / 2) - 6;

        // clear
        ctx.clearRect(0, 0, size, size);

        // optional face image (fit into circle)
        if (faceReady && faceImg) {
          // draw image centered and scaled to size
          ctx.save();
          // create circular clipping so image stays circular
          ctx.beginPath();
          ctx.arc(cx, cy, radius + 2, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();
          // draw image fill
          ctx.drawImage(faceImg, cx - size / 2, cy - size / 2, size, size);
          ctx.restore();
        } else {
          // fallback face (simple gradient)
          const g = ctx.createRadialGradient(cx - size * 0.12, cy - size * 0.2, radius * 0.1, cx, cy, radius);
          g.addColorStop(0, "#ffffff");
          g.addColorStop(1, "#f0f0f0");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        // outer rim
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.lineWidth = Math.max(2, size * 0.02);
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.stroke();

        // hour marks (Roman numerals could be added but we keep simple ticks)
        ctx.save();
        ctx.translate(cx, cy);
        for (let i = 0; i < 60; i++) {
          const ang = i * Math.PI / 30;
          const inner = radius - (i % 5 === 0 ? radius * 0.12 : radius * 0.06);
          const outer = radius - 4;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang) * inner, Math.sin(ang) * inner);
          ctx.lineTo(Math.cos(ang) * outer, Math.sin(ang) * outer);
          ctx.lineWidth = (i % 5 === 0 ? 3 : 1.3);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.stroke();
        }
        ctx.restore();

        // calculate angles (hours in 12h)
        const hour12 = h % 12;
        const hourAngle = (Math.PI * 2) * ((hour12 + m / 60 + s / 3600) / 12) - Math.PI / 2;
        const minuteAngle = (Math.PI * 2) * ((m + s / 60) / 60) - Math.PI / 2;
        const secondAngle = (Math.PI * 2) * (s / 60) - Math.PI / 2;

        // hour hand
        ctx.beginPath();
        ctx.lineCap = 'round';
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(hourAngle) * (radius * 0.5), cy + Math.sin(hourAngle) * (radius * 0.5));
        ctx.lineWidth = Math.max(6, size * 0.045);
        ctx.strokeStyle = '#222';
        ctx.stroke();

        // minute hand
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(minuteAngle) * (radius * 0.72), cy + Math.sin(minuteAngle) * (radius * 0.72));
        ctx.lineWidth = Math.max(4, size * 0.03);
        ctx.strokeStyle = '#111';
        ctx.stroke();

        // second hand
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(secondAngle) * -radius * 0.12, cy + Math.sin(secondAngle) * -radius * 0.12);
        ctx.lineTo(cx + Math.cos(secondAngle) * (radius * 0.9), cy + Math.sin(secondAngle) * (radius * 0.9));
        ctx.lineWidth = Math.max(2, size * 0.012);
        ctx.strokeStyle = '#c33';
        ctx.stroke();

        // center cap
        ctx.beginPath();
        ctx.arc(cx, cy, Math.max(4, size * 0.02), 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
      }

      // main update loop - tick every second
      function updateAll() {
        $('.clock-card').each(function (index) {
          const $card = $(this);
          const tz = $card.data('tz');
          const canvas = $(this).find('canvas')[0];
          const canvasObj = canvases.find(c => c.canvas === canvas);
          if (!canvasObj) return;
          const ctx = canvasObj.ctx;
          // compute time parts for this timezone
          const parts = getTimePartsForTimeZone(tz);
          // draw - size in CSS px (we used dpr transform earlier)
          const cssW = parseInt(getComputedStyle(canvas).width, 10);
          const cssH = parseInt(getComputedStyle(canvas).height, 10);
          // use parts.hour/minute/second
          drawClock(ctx, Math.min(cssW, cssH), parts.hour, parts.minute, parts.second, faceImg);
        });
      }

      // initial draw & set interval
      updateAll();
      // align next update to the start of next second to keep in sync
      const now = new Date();
      const msTillNextSecond = 1000 - now.getMilliseconds();
      setTimeout(function () {
        updateAll();
        setInterval(updateAll, 1000);
      }, msTillNextSecond + 2);

      // handle window resize (re-scale canvases for DPR)
      let resizeTimeout;
      $(window).on('resize', function () {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function () {
          $('.clock').each(function () {
            const canvas = this;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const cssW = parseInt(getComputedStyle(canvas).width, 10);
            const cssH = parseInt(getComputedStyle(canvas).height, 10);
            canvas.width = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          });
          updateAll();
        }, 120);
      });
    });
  </script>

</body>

</html>